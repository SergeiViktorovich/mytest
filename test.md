# 1. Расскажите, чем отличаются команды: "t.sh" ". t.sh" "/t.sh" "./t.sh"?  
* t.sh - Ищет исполняемый файл t.sh в каталогах, указанных в переменной PATH.  
И соответственно выдаст ошибку, что команда не найдена, т.к. файл t.sh там не указан.  
* t.sh - Выполняет скрипт в текущем shell, и, например, если внутри скрипта изменяется переменная PATH,  
это изменение сохранится в этом окружении.  
* /t.sh - Запустит скрипт, находящийся в корневом каталоге / (если он там есть и у него есть права на выполнение).  
* ./t.sh - Выполнит скрипт t.sh из текущего каталога (если у него есть права на выполнение).  
# 2. Проведите ревью bash-скрипта
```bash
#!/bin/bash
file=$1
if [ -f $file ]
then
    echo "File exists"
else
    echo "File does not exist"
fi
```
* Можно добавить проверку аргумента, т.е. был он передан или нет. Если переменная $file будет пустой, это может вызвать ошибки или некорректное поведение.  
В данном случае, если не передавать аргумент, то скрипт сообщит, что файл существует. По этой причине лучше добавить проверку, чтобы убедиться, что аргумент действительно был передан.  
* Рекомендуется всегда заключать переменные в кавычки. В данном случае переменная $file используется без кавычек, что может привести к ошибкам, если путь к файлу содержит пробелы.  
* Можно добавить обработку случая, когда аргумент указывает на директорию, а не на файл и сообщать об этом пользователю.  
```bash
#!/bin/bash

# Проверка, что аргумент был передан
if [ -z "$1" ]; then
    echo "Usage: $0 <filename>"
    exit 1
fi

file="$1"

# Проверка, что указанный путь ведет к файлу
if [ -f "$file" ]; then
    echo "File '$file' exists."
else
    if [ -d "$file" ]; then
        echo "'$file' is a directory, not a file."
    else
        echo "File '$file' does not exist."
    fi
fi
```
# 3. Клиент жалуется на проблемы в работе БД MySQL - простые запросы выполняются медленно. Опишите ваши действия.
1. Убедиться, что проблема существует. Попробую воспроизвести действия пользователя.  
2. Локализовать проблему. (на клиенте, сервере или промежуточном узле).  
3. Если база данных находится на отдельном сервере, необходимо убедиться, что нет сетевых задержек между сервером приложений и MySQL-сервером. Командами **ping** или **traceroute**, чтобы проверить время ответа и маршруты.  
4. Если проблема на сервере базы данных, то необходимо проверить не исчерпаны ли его ресурсы (процессор, память, диски). Утилитами **top**, **free -h**, **df -h**.  
5. Проверю версию MySQL, возможно установлена не та.  
6. Попробую подключиться к базе данных (**mysql -u root -p**) и посмотрю текущие запросы, которые выполняются на сервере (**SHOW PROCESSLIST;**).   
7. Для анализа медленных запросов можно использовать команду ниже. Она покажет, какие индексы используются, как происходит чтение данных:  
**EXPLAIN SELECT * FROM name_table WHERE name_column = 'value';**  
Это позволит увидеть, если запрос использует полный скан таблицы (**Full Table Scan**), что может быть причиной медленной работы.  
8. Провел обслуживание базы MySQL. Оптимизация таблиц (**OPTIMIZE TABLE name_table;**), обновление индексов и статистики (**ANALYZE TABLE name_table;**), проверка целостности таблиц (**CHECK TABLE name_table;**).  
# 4. На сервере закончилось свободное место, новые файлы не создаются, вывод df -h показывает что свободное место есть. Опишите причины по которым такое могло произойти?
Скорее всего на сервере закончились айноды (**Inodes**). Проверить количество свободных айнодов можно командой **df -i**. Если столбец **TUse%** показывает 100%, то так оно и есть.  
Решение:  
1.	Удалением ненужных файлов, (особенно мелких) которые занимают много айнодов.  
2.	Перенос данных на раздел с достаточным количеством айнодов.  
3.	Если в системе создаются очень мелкие файлы, можно рассмотреть использование другой файловой системы с большими лимитами на количество айнодов.  

Также это может связано с квотами на пользователя или группу. В этом случае команда **df -h** покажет свободное место, но для конкретного пользователя это место может быть недоступно из-за квоты. Проверить квоты можно командами **quota -u \<username\>** и **quota -g \<groupname\>**.  
Решение:  
1.	Увеличить лимит квот.  
2.	Удалить ненужные файлы для освобождения места в рамках установленной квоты.  

Еще вариант. Есть файлы, которые открыты процессами, но удалены. Если файл удалён, но он всё ещё используется каким-либо процессом, система не освободит дисковое пространство, пока процесс не завершится. Таким образом, **df -h** может показывать, что свободное место есть, но оно фактически занято удалёнными файлами.  
Можно использовать команду (**lsof | grep deleted**) для поиска таких файлов.  
Решение:  
1.	Перезапуск процесса, который держит файл открытым.  
2.	В крайнем случае, можно завершить процесс вручную, используя команду **kill PID** или **kill -9 PID**, чтобы освободить дисковое пространство.  
# 5. Достаточно ли команды iostat -x чтобы оценить реальную нагрузку на диск?
Нет, недостаточно, т.к. **iostat** показывает только средние показатели на момент вызова. И если есть кратковременные пиковые нагрузки, они могут остаться незамеченными. Также не дает понимания какие файлы или процессы создают нагрузку на диск.  
Дополнить эту информацию можно утилитой **iotop** (позволяет увидеть, кто именно нагружает диск) или **vmstat** (помогает понять, влияет ли на диск свопинг или системные блокировки). Также инструменты вроде **free**, **top** помогают понять, как работает файловая система и её кэш, что может объяснить невидимую в **iostat** нагрузку.  
# 6. Клиент просит подобрать отказоустойчивое решение с SLA 99.9% для 7 сайтов (Nginx, PHP, MySQL, Redis, Memcached), статика занимает 10ТБ и будет расти до 50ТБ в течении года, каждая БД занимает 50ГБ. Предложите решение, опишите для клиента техническую реализацию.
Для достижения SLA 99.9% и обеспечения отказоустойчивости для 7 сайтов с такой большой нагрузкой, необходимо развернуть распределённую архитектуру с кластерами для каждого компонента (Nginx, PHP, MySQL, Redis, Memcached), использовать облачное хранилище для статики и CDN для ускорения доставки контента. Облачные технологии помогут достичь высокой доступности, гибкости и простоты масштабирования, удовлетворяя текущие и будущие потребности бизнеса.  

**Распределённая архитектура:** Множество серверов и сервисов должны быть развернуты в отказоустойчивом режиме с балансировкой нагрузки.  
**Дублирование всех ключевых компонентов:** Важнейшие части инфраструктуры (сервера приложений, базы данных, кэш) должны быть продублированы для обеспечения отказоустойчивости.  
**Горизонтальное масштабирование:** Архитектура должна позволять масштабироваться в зависимости от нагрузки.  
#### Техническая реализация  
**Инфраструктура:**  
Kubernetes для оркестрации всех контейнеров (Nginx, PHP, Redis, MySQL, Memcached).  
Облачные провайдеры (например, Yandex Cloud) с поддержкой мультизонной доступности для обеспечения отказоустойчивости на уровне инфраструктуры.  
Elastic Load Balancer (ELB) для распределения входящего трафика между веб-серверами и зонами доступности.  
**Масштабирование:**  
Добавить динамическое авто-масштабирование ресурсов в зависимости от нагрузки.  
Поддержка S3-хранилища для хранения большого объема статики.  
# 7. Клиент просит подобрать сервер под базу данных для хранения логов всех действий на сайте и строить разнообразную аналитику по данным. Ожидаемый объем БД через 6 месяцев 900 ГБ. Опишите ваши рекомендации по выбору сервера и настройке БД для клиента?
Для хранения логов с объёмом базы данных в 900 ГБ и растущей аналитической нагрузкой, сервер должен обладать мощными процессорами, большим объёмом оперативной памяти и высокопроизводительными NVMe-дисками. База данных (например, **PostgreSQL**, **ClickHouse** или **Elasticsearch**) должна быть настроена с использованием индексов, партиционирования, кэширования и регулярных бэкапов. Такой подход обеспечит высокую производительность и отказоустойчивость системы, а также возможность масштабирования по мере роста объёма данных.  
#### Пример конфигурации сервера:  
Процессор: **2x Intel Xeon Silver 4210 (20 ядер, 2.2 ГГц)**.  
Оперативная память: **128 ГБ DDR4 ECC RAM (с возможностью расширения)**.  
Хранилище:
* **2 ТБ NVMe SSD для базы данных**.
* **2 ТБ SATA SSD/HDD для архивов и бэкапов**.  

Сетевая карта: **10 GbE NIC**.  
# 8. Расскажите каким образом вы будете блокировать в Nginx запросы вида "GET /?[a-z]{16} HTTP/1.1"?
Для блокировки запросов вида "GET /?[a-z]{16} HTTP/1.1" в **Nginx** можно использовать регулярные выражения в директиве **location**  
```bash
server {
    listen 80;
    server_name your_domain.com;

    # Блокировка запросов вида GET /?[a-z]{16}
    location ~* "^/\?[a-z]{16}$" {
        return 403; # Возвращаем ошибку 403 Forbidden
    }

    location / {
        # Ваше основное приложение или проксирование
        proxy_pass http://backend;
    }
}
```
**location ~* "^/\\?[a-z]{16}\$"**: Этот блок **location** использует регулярное выражение для проверки **URL**.  
~* означает регистронезависимую проверку (в данном случае это не критично, так как **a-z** уже задаёт только маленькие буквы).  
**^/\\?[a-z]{16}\$**: Это регулярное выражение проверяет запросы к корню сайта (**/**) с 16 буквами в нижнем регистре после вопросительного знака **?**.  
**return 403**: Если запрос соответствует этому шаблону, возвращается HTTP-ответ **403 Forbidden**, блокируя доступ.  

Также можно использовать блок **if**, который проверяет соответствие **URI** регулярному выражению, и, если оно подходит, возвращает ошибку:  
```bash
server {
    listen 80;
    server_name your_domain.com;

    location / {
        # Проверка запроса с помощью директивы 'if'
        if ($request_uri ~* "^/\?[a-z]{16}$") {
            return 403; # Возвращаем ошибку 403 Forbidden
        }

        # Ваше основное приложение или проксирование
        proxy_pass http://backend;
    }
}
```
**if (\$request_uri ~* "^/\\?[a-z]{16}\$")**: Директива **if** проверяет переменную **$request_uri** (полный **URI** запроса) на соответствие регулярному выражению.  
Если условие выполнено, запрос будет заблокирован с кодом 403.  
# 9. Какой из запросов MySQL самый тяжелый: [https://xpaste.pro/p/t4q0Lsp0?](https://xpaste.pro/p/t4q0Lsp0?) Расскажите как вы его выявили?
Основные критерии для определения тяжести запроса, это время выполнения запроса (**Query_time**), количество строк (**Rows_examined** / **Rows_sent**) и тип запроса (**SELECT** / **DELETE**).  
Запрос **DELETE** является более ресурсоемким, т.к. он блокирует таблицы.  
Самый тяжёлый запрос — это **Запрос 2** с точки зрения времени выполнения (**9.26 секунд**) и большого числа строк для удаления (**948,209**).  
Второй по тяжести запрос — **Запрос 4**, так как он просматривает наибольшее количество строк (**2,457,916**).  
Поэтому запросы можно ранжировать по тяжести так:
1. Запрос 2 (**DELETE**) — самый тяжёлый по времени.
2. Запрос 4 (**SELECT**) — тяжёлый по объёму данных.
3. Запрос 1 (**SELECT**) — умеренно тяжёлый.
4. Запрос 3 (**SELECT**) — наименее тяжёлый.  
# 10. Что происходит на сервере: [https://drive.google.com/file/d/1Cxkx6-428EQAX0-eiaq66H829ohnPp7q/view?usp=sharing](https://drive.google.com/file/d/1Cxkx6-428EQAX0-eiaq66H829ohnPp7q/view?usp=sharing) Опишите в формате ответа для клиента, если у вас есть предложения по оптимизации, также укажите их.
**md5_raid1** — процесс, связанный с RAID1-массивом (зеркалирование), который отвечает за синхронизацию данных между зеркальными дисками.  
**md5_resync** — процесс, который инициируется при восстановлении или пересборке RAID-массива после сбоя или подключения нового диска. Он читает и записывает большие объёмы данных, чтобы проверить целостность и согласованность массива.  
**Atop** показывает высокую нагрузку на диски **sdb**, **sdd** и **sdc**. Также используется почти вся оперативная память и swap. В CPU высокое значение **wait (> 10%)**.   
Причин высокой нагрузки на CPU и диски может быть несколько:

1.	**Ресинхронизация массива RAID1**

Если RAID-массив попал в состояние восстановления (например, после сбоя одного диска или после горячей замены), происходит интенсивное чтение/запись для синхронизации всех блоков. Процесс ресурсоёмкий и выполняет много операций ввода-вывода.  

2.	**Устаревший или перегруженный диск**

Один из дисков может работать медленно из-за износа, битых секторов или внутренних ошибок, замедляя синхронизацию.  

3.	**Неправильно настроенные параметры RAID**

Высокая нагрузка может быть вызвана слишком агрессивными параметрами синхронизации (например, слишком высокими значениями **sync_speed_min** и **sync_speed_max**).  
Рекомендации клиенту, проверить состояние дисков (например **smartctl -a /dev/sda**) и параметры синхронизации **RAID1**.  

![raid1](https://github.com/SergeiViktorovich/mytest/blob/master/Screenshot_3.jpg)  

# 11. Что происходит на сервере: [https://drive.google.com/file/d/1fgJaftjv53xCN7vgiJOaQlbfWkUqPgyd/view?usp=share_link](https://drive.google.com/file/d/1fgJaftjv53xCN7vgiJOaQlbfWkUqPgyd/view?usp=share_link) Опишите в формате ответа для клиента, если у вас есть предложения по оптимизации, также укажите их.  

**Atop** показывает высокую нагрузку на диск **sda**. Также используется почти вся оперативная память и **swap**. В CPU высокое значение **wait (> 10%)**.  

Высокая нагрузка на **MySQL** и диски может указывать на проблемы с производительностью, неправильную настройку базы данных или неэффективные запросы.

1.	**Неоптимальные SQL-запросы**

Долгие или тяжелые запросы, использующие много ресурсов (JOIN-ы, ORDER BY, GROUP BY без индексов). Отсутствие индексов на часто используемых столбцах.

2.	**Большое количество соединений**

Одновременно запущено множество клиентских соединений (например, от веб-приложения).

3.	**Проблемы с дисковой подсистемой**

Использование медленных **HDD** вместо **SSD**. Высокая конкуренция за I/O, вызванная параллельными процессами (резервные копии, репликация и т.д.).
Решение проблемы и оптимизация:  

1.	**Оптимизация SQL-запросов**

* Добавьте индексы на часто используемые столбцы.
* Переписать сложные запросы или использовать более эффективные JOIN-ы.
* Разделить большие запросы на более мелкие, если это возможно.

2.	**Ограничение количества соединений**

* Если много соединений от клиентов, установить лимит:

3.	**Перенос на быстрые диски (SSD)**

* Если дисковая подсистема ограничивает производительность, использовать SSD или NVMe-диски.

![myasl](https://github.com/SergeiViktorovich/mytest/blob/master/Screenshot_4.jpg)  

# 12. Какие зависимости (явные и неявные) используются в этой роли: [https://galaxy.southbridge.io/collections/aux/-/tree/master/roles/rhel_python_sub](https://galaxy.southbridge.io/collections/aux/-/tree/master/roles/rhel_python_sub)  

**meta/main.yml** – здесь обычно указываются зависимости от других ролей и коллекций.  

**dependencies:**  
Это ключ, в котором явно перечисляются зависимости от других ролей. В данном случае роль **rhel_python_sub** зависит от роли **southbridge.aux.repo_southbridge**  

**tasks/main.yml** – здесь можно увидеть, какие модули или роли вызываются напрямую, что также поможет понять неявные зависимости.  

Используется модуль **include_vars** и проверка **ansible_distribution_major_version**. Эти данные зависят от фактов (**facts**), собранных **Ansible** на целевой системе. Это требует, чтобы сбор фактов был включён (например, через **gather_facts: true**).  

**find** зависит от возможности **Ansible** выполнять команды на целевой системе, а также от того, что **Ansible** правильно настроен для доступа к системе.  

**package** предполагает, что на системе настроены репозитории, необходимые для установки пакетов (**python3** в этом случае). Если репозитории недоступны, установка завершится с ошибкой.  

**include_vars: "el{{ ansible_distribution_major_version }}.yml"**  
Эта директива подразумевает, что существуют файлы переменных, специфичные для версии ОС (например, **el7.yml** и **el8.yml**). Это создаёт зависимость от структуры файлов в роли: если эти файлы отсутствуют или названы неправильно, роль не выполнится корректно.  

```yml
when:
  - not __rhel_python_sub_find.files|length
  - ansible_distribution_major_version|int == 7
```
Роль выполняет установку **Python** только на версиях ОС 7, создавая зависимость от конкретной версии ОС. На других версиях логика роли может потребовать изменений или дополнительных настроек.  

# ** 13. Мы знаем, что есть всего 7 записей с ticket_id=56412. Записей с ticket_id > 60000 нет, никаких символов перед 56412 нет. Как могла появиться разница в количестве? Опишите ваши действия.  

```sql
- SELECT count(*) FROM tickets_messages WHERE ticket_id=56412; возвращает 5 записей
- SELECT count(*) FROM tickets_messages WHERE ticket_id like '%56412'; возвращает 7 записей
```

**Потенциальные причины разницы**  

1.	**Проблемы с типом данных**

Поле **ticket_id** может быть строковым (**VARCHAR**) вместо числового (**INT**), и записи могут содержать дополнительные символы или пробелы в конце.
Например, **ticket_id** может выглядеть как **56412** (с пробелом в конце), что подходит под условие **LIKE '%56412'**.

2.	**Дублирование данных или разные представления**

Значение **ticket_id** могло быть вставлено с разными форматами, например, как '**056412**' или '**56412 **'. Такие значения не будут соответствовать точному запросу **ticket_id=56412**.

3.	**Проблемы с NULL или пустыми значениями**

Могут существовать записи с пустыми или NULL-значениями, которые конкатенируются с **'56412'**, и попадают под условие **LIKE '%56412'**.

4.	**Ошибка при вставке или миграции данных**

При импорте данных могут возникнуть аномалии в форматах значений, например, использование строковых типов вместо числовых.
Скорее всего, разница возникает из-за того, что некоторые записи содержат пробелы, символы табуляции или другие скрытые символы. Запрос с **LIKE '%56412'** находит все такие записи, в то время как точное сравнение (**ticket_id=56412**) находит только чистые значения без лишних символов

